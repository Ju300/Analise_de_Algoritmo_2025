# -*- coding: utf-8 -*-
"""abb_comcodigobase_semantesoudepoisdaremocao

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FDKUgUpqHxka2zmlz-Nxar9yhQ1WWEsw
"""

# Definição da classe Nó, que representa cada elemento da Árvore Binária de Busca (com o código base dado pelo professor)
import random

class No:
    """ Classe que representa um nó da árvore binária """
    def __init__(self, valor):
        self.valor = valor
        self.esquerda = None
        self.direita = None

# ------------------- Inserção em ABB -------------------
def inserir_abb(raiz, valor):
    """ Insere um novo nó em uma ABB seguindo as regras de ordenação """
    if raiz is None:
        return No(valor)

    if valor < raiz.valor:
        raiz.esquerda = inserir_abb(raiz.esquerda, valor)
    else:
        raiz.direita = inserir_abb(raiz.direita, valor)

    return raiz

# ------------------- Pesquisa em ABB -------------------
def buscar_abb(raiz, valor):
    """ Pesquisa um valor na ABB e retorna True se encontrar, False caso contrário """
    if raiz is None:
        return False  # Árvore vazia ou valor não encontrado

    if valor == raiz.valor:
        return True  # Valor encontrado
    elif valor < raiz.valor:
        return buscar_abb(raiz.esquerda, valor)  # Busca na subárvore esquerda
    else:
        return buscar_abb(raiz.direita, valor)  # Busca na subárvore direita

# ------------------- Remoção em ABB -------------------
def remover_abb(raiz, valor):
    """ Remove um nó da ABB e mantém a estrutura correta """
    if raiz is None:
        return raiz  # Árvore vazia

    # Procurando o nó a ser removido
    if valor < raiz.valor:
        raiz.esquerda = remover_abb(raiz.esquerda, valor)
    elif valor > raiz.valor:
        raiz.direita = remover_abb(raiz.direita, valor)
    else:
        # Caso 1: Nó folha (sem filhos)
        if raiz.esquerda is None and raiz.direita is None:
            return None  # Apenas remove o nó

        # Caso 2: Nó com apenas um filho
        if raiz.esquerda is None:
            return raiz.direita
        elif raiz.direita is None:
            return raiz.esquerda

        # Caso 3: Nó com dois filhos
        sucessor = encontrar_min(raiz.direita)  # Menor valor da subárvore direita
        raiz.valor = sucessor.valor  # Substitui o valor pelo sucessor
        raiz.direita = remover_abb(raiz.direita, sucessor.valor)  # Remove o sucessor

    return raiz

def encontrar_min(no):
    """ Encontra o menor valor na subárvore direita (sucessor in-order) """
    atual = no
    while atual.esquerda is not None:
        atual = atual.esquerda
    return atual

# ------------------- Construção da ABB -------------------
def construir_abb(n):
    """ Constrói uma ABB com N nós gerados aleatoriamente """
    if n < 1:
        return None, []

    valores = random.sample(range(1, 100), n)  # Gera valores únicos aleatórios
    raiz = No(valores[0])  # Primeiro valor como raiz

    for valor in valores[1:]:  # Insere os demais valores na ABB
        inserir_abb(raiz, valor)

    return raiz, valores

# ------------------- Impressão da Árvore -------------------
def imprimir_arvore(raiz, nivel=0):
    """ Imprime a árvore de forma hierárquica """
    if raiz is not None:
        imprimir_arvore(raiz.direita, nivel + 1)
        print(' ' * 4 * nivel + '->', raiz.valor)
        imprimir_arvore(raiz.esquerda, nivel + 1)

# ------------------- Testando a ABB -------------------
N = 10  # Número de nós na ABB
arvore, valores = construir_abb(N)
print("Árvore ABB gerada:")
imprimir_arvore(arvore)
print("\nValores inseridos:", valores)

# Testando busca
busca_valor = valores[3]  # Pegando um valor já inserido
print(f"\nBuscando {busca_valor} na ABB: {'Encontrado' if buscar_abb(arvore, busca_valor) else 'Não encontrado'}")

# Testando remoção
remover_valor = valores[2]  # Pegando outro valor já inserido
print(f"\nRemovendo {remover_valor} da ABB...")
arvore = remover_abb(arvore, remover_valor)
imprimir_arvore(arvore)