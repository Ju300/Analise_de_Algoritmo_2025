# -*- coding: utf-8 -*-
"""abb_resoluçãosemcodigobase

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d89DACc89H4JtnJD7wjY91YZ3d_-Y1Wa
"""

# Definição da classe Nó, que representa cada elemento da Árvore Binária de Busca (sem o código base dado pelo professor)
class No:
    """
    Classe que representa um nó de uma Árvore Binária de Busca (ABB).
    Cada nó possui um valor (chave) e pode ter filhos à esquerda e à direita.
    """
    def __init__(self, chave):
        self.chave = chave  # Armazena o valor do nó
        self.esquerda = None  # Inicialmente, o nó não tem filho à esquerda
        self.direita = None  # Inicialmente, o nó não tem filho à direita

# Definição da classe ABB (Árvore Binária de Busca)
class ABB:
    """
    Classe que representa uma Árvore Binária de Busca (ABB).
    Permite realizar operações de inserção, busca e remoção de elementos.
    """
    def __init__(self):
        self.raiz = None  # Inicialmente, a árvore está vazia (sem nós)

    # Método para inserir um novo valor na ABB
    def inserir(self, chave):
        """
        Insere um novo valor na árvore, seguindo as regras da ABB:
        - Valores menores vão para a esquerda
        - Valores maiores vão para a direita
        """
        self.raiz = self._inserir_recursivo(self.raiz, chave)

    def _inserir_recursivo(self, no, chave):
        """
        Método auxiliar para inserção recursiva.
        :param no: Nó atual da árvore.
        :param chave: Valor a ser inserido.
        :return: Nó atualizado.
        """
        if no is None:
            return No(chave)  # Cria um novo nó se a posição estiver vazia

        if chave < no.chave:
            # Se o valor for menor, insere na subárvore esquerda
            no.esquerda = self._inserir_recursivo(no.esquerda, chave)
        elif chave > no.chave:
            # Se o valor for maior, insere na subárvore direita
            no.direita = self._inserir_recursivo(no.direita, chave)

        return no  # Retorna o nó atualizado

    # Método para buscar um valor na ABB
    def buscar(self, chave):
        """
        Retorna True se a chave estiver na árvore, False caso contrário.
        """
        return self._buscar_recursivo(self.raiz, chave)

    def _buscar_recursivo(self, no, chave):
        """
        Método auxiliar para busca recursiva.
        :param no: Nó atual da árvore.
        :param chave: Valor a ser buscado.
        :return: True se encontrado, False se não existir na árvore.
        """
        if no is None:
            return False  # Se chegou a um nó nulo, significa que a chave não existe

        if chave == no.chave:
            return True  # Se encontrou a chave, retorna True

        if chave < no.chave:
            return self._buscar_recursivo(no.esquerda, chave)  # Busca na subárvore esquerda
        else:
            return self._buscar_recursivo(no.direita, chave)  # Busca na subárvore direita

    # Método para remover um valor da ABB
    def remover(self, chave):
        """
        Remove um nó da árvore, tratando os três casos de remoção.
        """
        self.raiz = self._remover_recursivo(self.raiz, chave)

    def _remover_recursivo(self, no, chave):
        """
        Método auxiliar para remoção recursiva.
        :param no: Nó atual da árvore.
        :param chave: Valor a ser removido.
        :return: Nó atualizado após a remoção.
        """
        if no is None:
            return no  # Se o nó não existe, simplesmente retorna None

        if chave < no.chave:
            no.esquerda = self._remover_recursivo(no.esquerda, chave)  # Procura na esquerda
        elif chave > no.chave:
            no.direita = self._remover_recursivo(no.direita, chave)  # Procura na direita
        else:
            # Caso 1: Nó folha (sem filhos)
            if no.esquerda is None and no.direita is None:
                return None

            # Caso 2: Nó com um único filho
            if no.esquerda is None:
                return no.direita
            elif no.direita is None:
                return no.esquerda

            # Caso 3: Nó com dois filhos (encontra o sucessor)
            sucessor = self._menor_valor(no.direita)
            no.chave = sucessor.chave  # Substitui pelo sucessor
            no.direita = self._remover_recursivo(no.direita, sucessor.chave)  # Remove o sucessor

        return no  # Retorna o nó atualizado

    def _menor_valor(self, no):
        """
        Encontra o menor valor em uma subárvore (usado na remoção de um nó com dois filhos).
        """
        atual = no
        while atual.esquerda is not None:
            atual = atual.esquerda  # Vai sempre para a esquerda até encontrar o menor valor
        return atual

    # Método para percorrer a árvore em ordem crescente (esquerda, raiz, direita)
    def em_ordem(self):
        """
        Exibe os valores da árvore em ordem crescente.
        """
        self._em_ordem_recursivo(self.raiz)
        print()

    def _em_ordem_recursivo(self, no):
        """
        Método auxiliar para o percurso em ordem.
        :param no: Nó atual da árvore.
        """
        if no is not None:
            self._em_ordem_recursivo(no.esquerda)
            print(no.chave, end=" ")  # Exibe o valor do nó
            self._em_ordem_recursivo(no.direita)

# ** Testando a implementação **
if __name__ == "__main__":
    arvore = ABB()  # Cria uma nova árvore

    # Inserindo elementos na ABB
    valores = [50, 30, 70, 20, 40, 60, 80]
    for v in valores:
        arvore.inserir(v)

    print("Árvore em ordem após inserção:")
    arvore.em_ordem()  # Deve imprimir: 20 30 40 50 60 70 80

    # Buscando valores na árvore
    print("\nBuscando valores:")
    print("Busca por 40:", arvore.buscar(40))  # True
    print("Busca por 100:", arvore.buscar(100))  # False

    # Removendo um elemento
    arvore.remover(50)
    print("\nÁrvore em ordem após remover 50:")
    arvore.em_ordem()  # Deve imprimir: 20 30 40 60 70 80