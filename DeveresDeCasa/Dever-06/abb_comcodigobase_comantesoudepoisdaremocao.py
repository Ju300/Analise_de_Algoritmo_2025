# -*- coding: utf-8 -*-
"""abb_comcodigobase_comantesoudepoisdaremocao

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FDKUgUpqHxka2zmlz-Nxar9yhQ1WWEsw
"""

# Definição da classe Nó, que representa cada elemento da Árvore Binária de Busca (com o código base dado pelo professor com antes e depois da remoção)
import random

class No:
    """ Classe que representa um nó da árvore binária de busca """
    def __init__(self, valor):
        self.valor = valor
        self.esquerda = None
        self.direita = None

def inserir_abb(raiz, valor):
    """ Insere um novo nó em uma ABB seguindo as regras de ordenação """
    if raiz is None:
        return No(valor)

    if valor < raiz.valor:
        raiz.esquerda = inserir_abb(raiz.esquerda, valor)
    else:
        raiz.direita = inserir_abb(raiz.direita, valor)

    return raiz

def buscar_abb(raiz, valor):
    """ Pesquisa um valor na ABB e retorna True se encontrar, False caso contrário """
    if raiz is None:
        return False
    if valor == raiz.valor:
        return True
    elif valor < raiz.valor:
        return buscar_abb(raiz.esquerda, valor)
    else:
        return buscar_abb(raiz.direita, valor)

def remover_abb(raiz, valor):
    """ Remove um nó da ABB e mantém a estrutura correta """
    if raiz is None:
        return raiz

    if valor < raiz.valor:
        raiz.esquerda = remover_abb(raiz.esquerda, valor)
    elif valor > raiz.valor:
        raiz.direita = remover_abb(raiz.direita, valor)
    else:
        if raiz.esquerda is None:
            return raiz.direita
        elif raiz.direita is None:
            return raiz.esquerda

        sucessor = encontrar_min(raiz.direita)
        raiz.valor = sucessor.valor
        raiz.direita = remover_abb(raiz.direita, sucessor.valor)

    return raiz

def encontrar_min(no):
    """ Encontra o menor valor na subárvore direita (sucessor in-order) """
    while no.esquerda is not None:
        no = no.esquerda
    return no

def construir_abb(n):
    """ Constrói uma ABB com N nós gerados aleatoriamente """
    if n < 1:
        return None, []

    random.seed(42)  # Fixando a semente para previsibilidade
    valores = random.sample(range(1, 100), n)
    raiz = No(valores[0])

    for valor in valores[1:]:
        inserir_abb(raiz, valor)

    return raiz, valores

def imprimir_arvore(raiz, nivel=0):
    """ Imprime a árvore de forma hierárquica """
    if raiz is not None:
        imprimir_arvore(raiz.direita, nivel + 1)
        print(' ' * 4 * nivel + '->', raiz.valor)
        imprimir_arvore(raiz.esquerda, nivel + 1)

def imprimir_in_order(raiz):
    """ Imprime os valores da ABB em ordem crescente (in-order traversal) """
    if raiz:
        imprimir_in_order(raiz.esquerda)
        print(raiz.valor, end=" ")
        imprimir_in_order(raiz.direita)

# ------------------- Testando a ABB -------------------
N = 10
arvore, valores = construir_abb(N)
print("Árvore ABB gerada:")
imprimir_arvore(arvore)

print("\nValores inseridos:", valores)
print("\nValores in-order (deveria ser crescente):")
imprimir_in_order(arvore)

# Testando busca
busca_valor = valores[3]
print(f"\n\nBuscando {busca_valor} na ABB: {'Encontrado' if buscar_abb(arvore, busca_valor) else 'Não encontrado'}")

# Testando remoção
remover_valor = valores[2]
print(f"\nRemovendo {remover_valor} da ABB...")
print("\nAntes da remoção:")
imprimir_arvore(arvore)

arvore = remover_abb(arvore, remover_valor)

print("\nDepois da remoção:")
imprimir_arvore(arvore)